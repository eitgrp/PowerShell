<#
.SYNOPSIS
This script is a template for making changes to the registry.
To use it, simply copy the "$RegChange" array, and input your data.
Add a number to the end of each RegChange variable name, EG: $RegChange1, $RegChange2, etc.

.DESCRIPTION
Below are some notes on each variable and how to input data into them correctly

REGPATH
The registry path should begin with one of the prefixes below, followed by :\

HKCR (HKEY_CLASSES_ROOT) / HKCU (HKEY_CURRENT_USER) / HKLM (HKEY_LOCAL_MACHINE) / HKU (HKEY_USERS) / HKCC (HKEY_CURRENT_CONFIG) 

So for the Local Machine hive, the path would begin with "HKLM:\"

REG ITEM NAME
The reg item name is the name of the value you're adding, for example "EnableSecuritySignature"

VALUE OF REG ITEM
Value of reg item is the data against that value, so to enable security signatures, you would set this to 1
!!! PLEASE NOTE IF THE VALUE OF THE REG ITEM IS A NUMBER, THEN DO NOT PUT QUOTATIONS AROUND THE NUMBER, AS IT WILL INTERPRET IT AS TEXT !!!

PROPERTY TYPE
Property type has to match one of the datatypes in the documenation for "reg add", any variation from these will stop the script from running.
These two will be the only datatypes you need 99% of the time, the others rarely need editing.
REG_SZ
REG_DWORD

.EXAMPLE
$RegChange = @(
    "REG PATH",
    "REG ITEM NAME",
    "VALUE OF REG ITEM",
    "PROPERTY TYPE"
)

$RegChange1 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange2 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "EnableSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange3 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

.NOTES
This script does not support remote registries or manually loaded hives.

It will make directories it cannot find but only to 2 levels
If it cannot find HKLM:\x\y\z for exmaple, it wont rebuild, however it cannot find HKLM:\x\y it will make the directories x and y #>

################################################################################################################################################
# !!! This array is here as a TEMPLATE ONLY, it will NOT be picked up by the script !!! #
$RegChange = @(
    "REG PATH",
    "REG ITEM NAME",
    "VALUE OF REG ITEM",
    "PROPERTY TYPE"
)

# Edit this to give your script a title that appears when executed
Write-Host "*******************************"
Write-Host "******** SCRIPT TITLE *********"
Write-Host "*******************************"
Write-Host "***** Available Commands: *****"
Write-Host "*********** Commit ************"
Write-Host "*********** Revert ************"
Write-Host "*******************************"

[array]$ChangeList = Get-Variable | Where {$_.Name -like "RegChange?*"}
$BackupPath = "C:\Source\Registry-Backups"
function BackupReg {
    if (Test-Path $BackupPath -PathType Container) {
        $BackupExist = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf
        if ($BackupExist) {
            return "Successfully found a backup of $RegPath"
        }
    } ELSE {
        New-Item -Path "C:\Source\" -name "Registry-Backups" -ItemType Directory 
    }
    reg save ($RegPath).Replace(":","") ($BackupPath + $BackupFile)

    $BackupCreated = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf

    if ($BackupCreated) {
        Write-Host "Successfully created a backup of $RegPath"
    } ELSE {
        Write-Host "Failed to create a backup of the registry key: $RegPath"
    }
}

function DataValidation {
    # Preparing the data to be validated by the subsequent switch statements
    if ($RegPath -like "Computer\*") {
        $RegPath = $RegPath.TrimStart("Computer\")
    }
    # If the user has entered the wrong format, correct it
    switch -Wildcard ($RegPath) {
        "HKEY_CLASSES_ROOT*" { $RegPath = $RegPath.Replace("HKEY_CLASSES_ROOT","HKCR:") }
        "HKEY_CURRENT_USER*" { $RegPath = $RegPath.Replace("HKEY_CURRENT_USER","HKCU:") }
        "HKEY_LOCAL_MACHINE*" { $RegPath = $RegPath.Replace("HKEY_LOCAL_MACHINE","HKLM:") }
        "HKEY_USERS*" { $RegPath = $RegPath.Replace("HKEY_USERS","HKU:") }
        "HKEY_CURRENT_CONFIG*" { $RegPath = $RegPath.Replace("HKEY_CURRENT_CONFIG","HKCC:") }
    }
    # Now that we've corrected any easy mistakes, make sure the format is correct
    switch -Wildcard ($RegPath) {
        "HKCR:\*" {}
        "HKCU:\*" {}
        "HKLM:\*" {}
        "HKU:\*" {}
        "HKCC:\*" {}
        default { return "Unrecognised data - The hive of the RegPath does not match any supported hives. Please double check the RegPath variable" }
    }
    # We know any datatypes outside of these will not be supported, so make sure it matches them
    switch ($DataType) {
        "REG_SZ" {}
        "REG_MULTI_SZ" {}
        "REG_DWORD" {}
        "REG_BINARY" {}
        "REG_DWORD_BIG_ENDIAN" {}
        "REG_DWORD_LITTLE_ENDIAN" {}
        "REG_LINK" {}
        "REG_FULL_RESOURCE_DESCRIPTOR" {}
        "REG_EXPAND_SZ" {}
        default { return "Unrecognised data type in $ChangeName! Please double check the data type variable (Fourth variable down)." }
    }
    # Easy mistake to make when working with binary dwords, so this logic should handle some of those mistakes
    switch ($Value) {
        "0" {$Value = 0}
        "1" {$Value = 1}
    }
}

function PathCheck {
    $path = $RegPath
    $PathType = "Container"
    if (!Test-Path -Path $path -PathType $PathType) {
        [array]$SplitPath = $path.split("\")
        $SectionCount = ($SplitPath | Measure-Object).Count
        $x = 0
        DO {
            $PathType = "Container"
            $x++
            $y = $SectionCount - $x
            [string]$z = ($SplitPath[0..$y] -join '\')
            $FindFault = Test-Path -Path $z -PathType $PathType
            if ($y -eq 1) { Return "The registry path for $ChangeName is broken at the root! Please double check the RegPath variable (first variable)" }
        } Until($FindFault)
        # If path is only out by two sections at the end of the path, then we rebuild using the reverse of the logic above
        if (($FindFault) -and ($x -lt 2)) {
            DO {
                $y = $SectionCount - $x
                [string]$z = ($SplitPath[0..$y] -join '\')
                New-Item -Path $z -Name $SplitPath[$y + 1] -PathType Directory
                $x--
            } Until (($X -eq 0))
            if ((Test-Path -Path $Path -Pathtype $PathType) -and ($FindFault)) {
                Return "Path found. Keys were added to the directory as they could not be found."
            } ELSE { Return "ERROR - Tried to rebuild path for $ChangeName but still cannot find the path."
        } ELSE {
            Return "ERROR - The registry path for $ChangeName is broken. The path breaks at $z"
            }
    } ELSE { Return "Path found. The path was found without any intervention needed."; }
}

function CommitChange {

    $TestBackup = Test-Path -Path ($BackupPath + $BackupFile) -pathtype Leaf
    if (!$TestBackup) {
        return "
        Cannot find backup for the registry change $ChangeName
        
        Skipping the change..."
    }

    reg add ($RegPath.Replace(":","")) /v $RegEntry /t $DataType /d $Value /f
    $NewValue = Get-ItemPropertyValue -Path $RegPath -Name $RegEntry

    if ($NewValue -eq $Value) {
        Return "Successfully changed the value of $RegEntry in $RegPath"
    }
    ELSE {
        Return "$ChangeName is not the expected value after changing! The value is $NewValue"
    }
}

###########################################
# Commands that will be given to the user #
###########################################

function Commit {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = "backup$($RegPath.Replace("\","-"),(":","-")).reg"
        if ((Get-ItemPropertyValue -Path $RegPath -Name $RegEntry -ErrorAction SilentlyContinue) -eq $Value) {
            Write-Information "The change $ChangeName is already the desired value! Skipping..."
        } ELSE { 
            $ValidData = DataValidation
            if ($ValidData -notlike "Unrecognised data*") {
            $PathValid = PathCheck
            if ($PathValid -like "Path found*") {
                BackupReg
                CommitChange
                } ELSE { Write-Information "Cannot find path specified in $ChangeName, skipping..." }
            } ELSE {
                Write-Information "$ChangeName has invalid data, skipping..."
            }
        }
    }
}

function Revert {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        DataValidation
        $script:BackupFile = "backup$($RegPath.Replace("\","-"),(":","-")).reg"
        $RestoreOperation = Reg Restore ($RegPath).Replace(":","") ($BackupPath + $BackupFile)
        if ($RestoreOperation -match "The operation completed successfully.") {
            Write-Host "Successful restored the registry for path: $RegPath"
        } ELSE {
            Write-Host "Failed to restore the registry for the path: $RegPath"
        }
    }
}
