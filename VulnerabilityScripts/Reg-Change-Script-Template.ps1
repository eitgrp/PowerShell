<#
.SYNOPSIS
This script is a template for making changes to the registry.
To use it, simply copy the "$RegChange" array, and input your data.
Each array must have a unique name, so I recommend the following naming convention:
Add a number to the end of each RegChange variable name, followed by some descriptive words, EG: $RegChange1SMBWorkstation, $RegChange2SMBServer, etc.

.DESCRIPTION
Below are some notes on each variable and how to input data into them correctly

REGPATH
The registry path should begin with one of the prefixes below, followed by :\

HKCR (HKEY_CLASSES_ROOT) / HKCU (HKEY_CURRENT_USER) / HKLM (HKEY_LOCAL_MACHINE) / HKU (HKEY_USERS) / HKCC (HKEY_CURRENT_CONFIG) 

So for the Local Machine hive, the path would begin with "HKLM:\"

REG ITEM NAME
The reg item name is the name of the value you're adding, for example "EnableSecuritySignature"

VALUE OF REG ITEM
Value of reg item is the data against that value, so to enable security signatures, you would set this to 1

PROPERTY TYPE
Property type has to match one of the datatypes in the documenation for "reg add", any variation from these will stop the script from running.
These two will be the only datatypes you need 99% of the time, the others rarely need editing.
REG_SZ
REG_DWORD

.EXAMPLE
$RegChange = @(
    "REG PATH",
    "REG ITEM NAME",
    "VALUE OF REG ITEM",
    "PROPERTY TYPE"
)

$RegChange1SMBSigning = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange2SMBSigning = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "EnableSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange3SMBSigning = @(
    "HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

.NOTES
This script does not support remote registries or manually loaded hives.

It will make directories it cannot find but only to 2 levels
If it cannot find HKLM:\x\y\z for exmaple, it wont rebuild, however it cannot find HKLM:\x\y it will make the directories x and y
This feature can be turned via the $RebuildMode variable ($false/$true) below
#>

################################################################################################################################################

# !!! This array is here as a TEMPLATE ONLY, it will NOT be picked up by the script !!! #
        $RegChange = @(
        "REG PATH",
        "REG ITEM NAME",
        "VALUE OF REG ITEM",
        "PROPERTY TYPE"
    )

    $RegChange1SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
        "RequireSecuritySignature",
        "1",
        "REG_DWORD"
    )

    $RegChange2SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
        "EnableSecuritySignature",
        "1",
        "REG_DWORD"
    )

    $RegChange3SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters",
        "RequireSecuritySignature",
        "1",
        "REG_DWORD"
    )

############
# Controls #
############

$BackupPath = "C:\Source\Registry-Backups\"
# Path for the registry backup files

$RebuildMode = $false
# Rebuild broken paths

# Edit this to give your script a title that appears when executed
Write-Host "*******************************"
Write-Host "******** SCRIPT TITLE *********"
Write-Host "*******************************"
Write-Host "***** Available Commands: *****"
Write-Host "*********** Commit ************"
Write-Host "*********** Revert ************"
Write-Host "*******************************"

###################################
# !!! SCRIPT CODE STARTS HERE !!! #
###################################

[array]$ChangeList = Get-Variable | Where {$_.Name -like "RegChange?*"}


function DataValidation {

    # Double checking there's a backslash at the end of the backup path so we can join reliably regardless if the user put it there or not
    If (!$BackupPath.EndsWith("\")) {
        $BackupPath = $BackupPath + "\"
    }
    Write-Host "Checking path"
    # Preparing the data to be validated by the subsequent switch statements by corrected an easy to make error
    if ($RegPath.StartsWith('Computer\')) {
        $script:RegPath = $RegPath.Replace("Computer\","")
    }
    # If the user has entered the wrong format, correct it
    switch -Wildcard ($RegPath) {
        "HKEY_CLASSES_ROOT*" {  $script:RegPath = $RegPath.Replace("HKEY_CLASSES_ROOT","HKCR:") }
        "HKEY_CURRENT_USER*" {  $script:RegPath = $RegPath.Replace("HKEY_CURRENT_USER","HKCU:")   }
        "HKEY_LOCAL_MACHINE*" {  $script:RegPath = $RegPath.Replace("HKEY_LOCAL_MACHINE","HKLM:")   }
        "HKEY_USERS*" {  $script:RegPath = $RegPath.Replace("HKEY_USERS","HKU:") }
        "HKEY_CURRENT_CONFIG*" {  $script:RegPath = $RegPath.Replace("HKEY_CURRENT_CONFIG","HKCC:")  }
        ELSE {  }
    }
    Write-Host "Done checking path, verifying"
    # Now that we've corrected any easy mistakes, make sure the format is correct
    switch -Wildcard ($RegPath) {
        "HKCR:\*" {}
        "HKCU:\*" {}
        "HKLM:\*" {}
        "HKU:\*" {}
        "HKCC:\*" {}
        else { Return "Unrecognised data - The hive of the RegPath does not match any supported hives. Please double check the RegPath variable" }
    }
    Write-Host "Checking datatype"

    # We know any datatypes outside of these will not be supported, so make sure it matches them
    switch ($DataType) {
        "REG_SZ" {
            # Setting the value to a string as string registry entries require strings (obviously...)
            $Value = [string]$Value
            
        }
        "REG_MULTI_SZ" {}
        "REG_DWORD" {
            # Setting the value to an int as DWords only accept integers
            $Value = [int]$Value
            
        }
        "REG_BINARY" {}
        "REG_DWORD_BIG_ENDIAN" {}
        "REG_DWORD_LITTLE_ENDIAN" {}
        "REG_LINK" {}
        "REG_FULL_RESOURCE_DESCRIPTOR" {}
        "REG_EXPAND_SZ" {}
        ELSE { Return "Unrecognised data type in $ChangeName! Please double check the data type variable (Fourth variable down)." }
    }
    Return "Data Valid"
}
function PathCheck {
    $path = $RegPath
    $PathType = "Container"
    $test = Test-Path -Path $path -PathType $PathType

if (!$test) {
    [array]$SplitPath = $path.split("\")
    $SectionCount = ($SplitPath | Measure-Object).Count
    $x = 0
    DO {
        $PathType = "Container"
        $x++
        $y = $SectionCount - $x
        [string]$z = ($SplitPath[0..$y] -join '\')
        $FindFault = Test-Path -Path $z -PathType $PathType
        if ($y -eq 1) { Return "The registry path for $ChangeName is broken at the root! Please double check the RegPath variable (first variable)" }
    } Until($FindFault)

    # If path is only out by two sections at the end of the path, then we rebuild using the reverse of the logic above
    $Script:BackupRegPath = ($SplitPath[0..$y] -join '\')
    $x--
    if (($FindFault) -and ($x -le 2) -and ($RebuildMode)) {
		DO {
			$y = 0 + $SectionCount - $x
			[string]$z = ($SplitPath[0..($y - 1)] -join '\')
			New-Item -Path $z -Name $Splitpath[$y] -ItemType Directory
		    $x--
		} Until (($X -eq 0))
	}
            if ((Test-Path -Path $Path -Pathtype $PathType) -and ($FindFault)) {

                Return "Path found. Keys were added to the directory as they could not be found."
            } ELSE { Return "ERROR - Tried to rebuild path for $ChangeName but still cannot find the path."
        } ELSE {
            Return "ERROR - The registry path for $ChangeName is broken. The path breaks at $z"
            }
    } ELSE {
        $Script:BackupRegPath = $RegPath
        Return "Path found. The path was found without any intervention needed."; }
}

function BackupReg {
    if (Test-Path $BackupPath -PathType Container) {
        $BackupExist = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf
        if ($BackupExist) {
            return "Successfully found a backup of $RegPath"
        }
    } ELSE {
        Write-Host "Making backup folder..."
        New-Item -Path "C:\Source\" -name "Registry-Backups" -ItemType Directory -Force
    }

    reg save ($BackupRegPath).Replace(":","") ($BackupPath + $BackupFile + ".reg")
    $BackupCreated = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf

    if ($BackupCreated) {
        return "Successfully created a backup of $RegPath"
    } ELSE {
        return "Failed to create a backup of the registry key: $RegPath"
    }
}

function CommitChange {

    reg add ($RegPath.Replace(":","")) /v $RegEntry /t $DataType /d $Value /f
    $NewValue = Get-ItemPropertyValue -Path $RegPath -Name $RegEntry

    if ($NewValue -eq $Value) {
        Return "Successfully changed the value of $RegEntry in $RegPath"
    }
    ELSE {
        Return "$ChangeName is not the expected value after changing! The value is $NewValue"
    }
}

###########################################
# Commands that will be given to the user #
###########################################

function Commit {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = $ChangeName + ".reg"
        Write-Host "Starting"
        Write-Host "Validating Data..."
        $ValidData = DataValidation
        if ($ValidData -notlike "Unrecognised data*") {
            Write-Host "Validating Path..."
            $PathValid = PathCheck
            if ((Get-ItemPropertyValue -Path $RegPath -Name $RegEntry -ErrorAction SilentlyContinue) -eq $Value) {
                Write-Output "$ChangeName is already the desired value! Skipping..."
                break
            }
            if ($PathValid -like "Path found*") {
                Write-Host "Backing up registy..."
                $Backup = BackupReg
                if ($Backup -like "Successfully*") {
                    Write-Host "Committing change..."
                    CommitChange
                }
                else { Write-host "No backup for $ChangeName, skipping change..." }
            }
            ELSE { Write-Output "Cannot find path specified in $ChangeName, skipping..." }                
        }  
        ELSE { Write-Output "$ChangeName has invalid data, please double check the variables for this change." }
    } 
}
function Revert {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = $ChangeName + ".reg"
        DataValidation
        $RestoreOperation = Reg Restore ($RegPath).Replace(":","") ($BackupPath + $BackupFile)
        if ($RestoreOperation -match "The operation completed successfully.") {
            Write-Host "Successful restored the registry for path: $RegPath"
        } ELSE { Write-Host "Failed to restore the registry for the path: $RegPath" }
    }
}
