<#
.SYNOPSIS
This script is a template for making changes to the registry.
To use it, simply copy the "$RegChange" array, and input your data.
Add a number to the end of each RegChange variable name, EG: $RegChange1, $RegChange2, etc.

.DESCRIPTION
Below are some notes on each variable and how to input data into them correctly

**** REGPATH ****
The registry path should begin with one of the prefixes below, followed by :\

HKCR (HKEY_CLASSES_ROOT) / HKCU (HKEY_CURRENT_USER) / HKLM (HKEY_LOCAL_MACHINE) / HKU (HKEY_USERS) / HKCC (HKEY_CURRENT_CONFIG) 

So for the Local Machine hive, the path would begin with "HKLM:\"

**** REG ITEM NAME ****
The reg item name is the name of the value you're adding, for example "EnableSecuritySignature"

**** VALUE OF REG ITEM ****
Value of reg item is the data against that entry, so to enable security signatures, you would set this to 1
!!! PLEASE NOTE IF THE VALUE OF THE REG ENTRY IS A NUMBER, DO NOT PUT QUOTATIONS AROUND THE NUMBER, AS IT WILL INTERPRET IT AS TEXT !!!

**** PROPERTY TYPE ****
Property type has to match one of the datatypes in the documenation for "reg add", any variation from these will stop the script from running.
REG_SZ
REG_DWORD
!!! These two above will be the only datatypes you need 99% of the time, the others rarely need editing. !!!

.EXAMPLE
$RegChange = @(
    "REG PATH",
    "REG ITEM NAME",
    "VALUE OF REG ITEM",
    "PROPERTY TYPE"
)

$RegChange1 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange2 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
    "EnableSecuritySignature",
    1,
    "REG_DWORD"
)

$RegChange3 = @(
    "HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters",
    "RequireSecuritySignature",
    1,
    "REG_DWORD"
)

.NOTES
This script does not support remote registries or manually loaded hives.

It also does not (currently) support dynamic building of paths. If it cannot find the path in "RegPath", it will skip the change.
I plan to add support for building paths it cannot find, however it needs planning to minimize risk. #>

################################################################################################################################################

# !!! This array is here as a TEMPLATE ONLY, it will NOT be picked up by the script !!! #
$RegChange = @(
    "REG PATH",
    "REG ITEM NAME",
    "VALUE OF REG ITEM",
    "PROPERTY TYPE"
)

# Edit this to give your script a title that appears when executed
Write-Host "*******************************"
Write-Host "******** SCRIPT TITLE *********"
Write-Host "*******************************"
Write-Host "***** Available Commands: *****"
Write-Host "*********** Commit ************"
Write-Host "*********** Revert ************"
Write-Host "*******************************"

[array]$ChangeList = Get-Variable | Where {$_.Name -like "RegChange?*"}
$BackupPath = "C:\Source\Registry-Backups"
function BackupReg {
    if (Test-Path $BackupPath -PathType Container) {
        $BackupExist = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf
        if ($BackupExist) {
            return "Successfully found a backup of $RegPath"
        }
    } ELSE {
        New-Item -Path "C:\Source\" -name "Registry-Backups" -ItemType Directory 
    }

    reg save ($RegPath).Replace(":","") ($BackupPath + $BackupFile)

    $BackupCreated = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf

    if ($BackupCreated) {
        Write-Host "Successfully created a backup of $RegPath"
    } ELSE {
        Write-Host "Failed to create a backup of the registry key: $RegPath"
    }
}

function DataValidation {
    # Preparing the data to be validated by the subsequent switch statements
    if ($RegPath -like "Computer\*") {
        $RegPath = $RegPath.TrimStart("Computer\")
    }
    # If the user has entered the wrong format, correct it
    switch -Wildcard ($RegPath) {
        "HKEY_CLASSES_ROOT*" { $RegPath = $RegPath.Replace("HKEY_CLASSES_ROOT","HKCR:") }
        "HKEY_CURRENT_USER*" { $RegPath = $RegPath.Replace("HKEY_CURRENT_USER","HKCU:") }
        "HKEY_LOCAL_MACHINE*" { $RegPath = $RegPath.Replace("HKEY_LOCAL_MACHINE","HKLM:") }
        "HKEY_USERS*" { $RegPath = $RegPath.Replace("HKEY_USERS","HKU:") }
        "HKEY_CURRENT_CONFIG*" { $RegPath = $RegPath.Replace("HKEY_CURRENT_CONFIG","HKCC:") }
    }
    # Now that we've corrected any easy mistakes, make sure the format is correct
    switch -Wildcard ($RegPath) {
        "HKCR:\*" {}
        "HKCU:\*" {}
        "HKLM:\*" {}
        "HKU:\*" {}
        "HKCC:\*" {}
        default { return "Unrecognised data - The hive of the RegPath does not match any supported hives. Please double check the RegPath variable" }
    }
    # We know any datatypes outside of these will not be supported, so make sure it matches them
    switch ($DataType) {
        "REG_SZ" {}
        "REG_MULTI_SZ" {}
        "REG_DWORD" {}
        "REG_BINARY" {}
        "REG_DWORD_BIG_ENDIAN" {}
        "REG_DWORD_LITTLE_ENDIAN" {}
        "REG_LINK" {}
        "REG_FULL_RESOURCE_DESCRIPTOR" {}
        "REG_EXPAND_SZ" {}
        default { return "Unrecognised data type in $ChangeName! Please double check the data type variable (Fourth variable down)." }
    }
    # Easy mistake to make when working with binary dwords, putting the number in a string, so this logic should handle some of those mistakes
    switch ($Value) {
        "0" {$Value = 0}
        "1" {$Value = 1}
    }
}

function PathCheck {
    $path = $RegPath
    $PathType = "Any"
    if (!Test-Path -Path $path -PathType $PathType) {
        [array]$SplitPath = $path.split("\")
        $SectionCount = ($SplitPath | Measure-Object).Count
        $x = 0
        DO {
            $PathType = "Container"
            $x++
            $y = $SectionCount - $x
            [string]$z = ($SplitPath[0..$y] -join '\')
            $FindFault = Test-Path -Path $z -PathType $PathType
            if ($y -eq 1) { Return "The registry path for $ChangeName is broken at the root! Please double check the RegPath variable (first variable)" }
        } Until($FindFault)
        Return "The registry path for $ChangeName is broken. The path breaks at $z"
    } ELSE { Return $true; }
}

function CommitChange {

    $TestBackup = Test-Path -Path ($BackupPath + $BackupFile) -pathtype Leaf
    if (!$TestBackup) {
        return "
        Cannot find backup for the registry change $ChangeName
        
        Skipping the change..."
    }

    reg add ($RegPath.Replace(":","")) /v $RegEntry /t $DataType /d $Value /f
    $NewValue = Get-ItemPropertyValue -Path $RegPath -Name $RegEntry

    if ($NewValue -eq $Value) {
        Return "Successfully changed the value of $RegEntry in $RegPath"
    }
    ELSE {
        Return "$ChangeName is not the expected value after changing! The value is $NewValue"
    }
}

###########################################
# Commands that will be given to the user #
###########################################

function Commit {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = "backup$($RegPath.TrimStart("HKLM:").Replace("\","-")).reg"
        if ((Get-ItemPropertyValue -Path $RegPath -Name $RegEntry -ErrorAction SilentlyContinue) -eq $Value) {
            Write-Host "The change $ChangeName is already the desired value! Skipping..."
        } ELSE { 
            $ValidData = DataValidation
            if ($ValidData -notlike "Unrecognised data*") {
            PathCheck
            BackupReg
            CommitChange
            } ELSE {
                Write-host "$ChangeName has invalid data, skipping..."
            }
        }
    }
}

function Revert {
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        DataValidation
        $BackupFile = "backup$($RegPath.TrimStart("???*:").Replace("\","-")).reg"
        $RestoreOperation = Reg Restore ($RegPath).Replace(":","") ($BackupPath + $BackupFile)
        if ($RestoreOperation -like "The operation completed successfully.") {
            Write-Host "Successful restored the registry for path: $RegPath"
        } ELSE {
            Write-Host "Failed to restore the registry for the path: $RegPath"
        }
    }
}
